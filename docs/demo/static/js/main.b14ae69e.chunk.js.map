{"version":3,"sources":["../../src/Utils/Types.ts","../../src/Utils/XPath.ts","../../src/index.tsx","../../src/ApplyTemplates/ApplyTemplates.tsx","../../src/CallTemplate/CallTemplate.tsx","../../src/ValueOf/ValueOf.tsx","../../src/Template/Template.tsx","../../src/Stylesheet/Stylesheet.tsx","../../src/If/If.tsx","../../src/ForEach/ForEach.tsx","../../src/Utils/Context.tsx","Components/context.ts","Components/Root.tsx","Components/Title.tsx","Components/Text.tsx","Components/Para.tsx","Components/index.ts","App.tsx","index.tsx"],"names":["computeXPathFromElement","contextNode","segments","currentNode","element","sibling","nth","Node","document","name","TypeError","XPathDataType","ApplyTemplates","__processTemplate","Template","this","props","contextData","getTemplateByNode","ctx","node","key","index","notFoundTemplateNode","render","xpath","select","mode","React","CallTemplate","getTemplateByName","notFoundTemplateName","ValueOf","separator","__observer","onBeforeMutate","callback","onAfterMutate","path","__setupObserver","MutationObserver","subtree","childList","attributes","characterData","__onMutate","componentDidMount","Stylesheet","__render","Component","If","result","children","ForEach","Context","__templates","__nsResolver","contextDocument","sortedTemplate","sort","templateA","templateB","notFoundStyleSheet","className","doc","resultType","XPathResult","Array","filter","template","query","Object","register","options","priority","RootStylesheet","Transformer","Root","title","Title","hasAttribute","textContent","getAttribute","onClick","onClickHandler","bind","Text","test","Para","App","state","undefined","fetch","text","xml","DOMParser","parseFromString","setState","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.b14ae69e.chunk.js","sourcesContent":["/**\n * A XPath query.\n */\nexport type XPath = string;\n\n/**\n * The return type of a XPath query.\n */\nexport enum XPathDataType {\n  /**\n   * Any value.\n   */\n  Any = 0,\n  /**\n   * A number.\n   */\n  Number = 1,\n  /**\n   * A string.\n   */\n  String = 2,\n  /**\n   * A boolean.\n   */\n  Boolean = 3,\n  /**\n   * An iterator on nodes, in any order.\n   */\n  UnorderedNodeIterator = 4,\n  /**\n   * An iterator on nodes, ordered from top to bottom of the XML.\n   */\n  OrderedNodeIterator = 5,\n  /**\n   * An array of nodes, in any order.\n   */\n  UnorderedNodeList = 6,\n  /**\n   * An array of nodes, ordered from top to bottom of the XML.\n   */\n  OrderedNodeList = 7,\n  /**\n   * Any node matching the query.\n   */\n  AnyNode = 8,\n  /**\n   * The first node matching the query, from top to bottom.\n   */\n  FirstNode = 9,\n}\n","import { XPath } from \"./Types\";\n\n/**\n * Computes the XPath for a given element.\n *\n * *Implementation details*:\n * - if the node or a parent has an `id` attribute, and it is the single node that has this `id`, then it will be used as the top node of the query.\n * - if the node or a parent is a processing instruction, a comment or a DTD, it will throw a `TypeError`.\n * - it will ignore document fragments.\n *\n * @param {Node} contextNode the node to compute the XPath from\n * @returns {XPath} the XPath\n */\nexport function computeXPathFromElement(contextNode: Node): XPath {\n  const segments: string[] = [];\n  let currentNode: Node | null = contextNode;\n  for (; currentNode !== null; currentNode = currentNode.parentNode) {\n    const element = currentNode as Element;\n    let sibling = contextNode.previousSibling;\n    let nth = 1;\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        if (\n          element.hasAttribute(\"id\") &&\n          document.querySelectorAll(`#${element.getAttribute(\"id\")}`).length ===\n            1\n        ) {\n          segments.unshift(`//id(\"${element.getAttribute(\"id\")}\")`);\n          return segments.join(\"/\");\n        } else {\n          const name = element.nodeName;\n          let sibling = element.previousSibling;\n          let nth = 1;\n          for (; sibling !== null; sibling = sibling.previousSibling) {\n            if (sibling.nodeName === name) nth++;\n          }\n          segments.unshift(\n            `*[local-name()='${element.localName}' and namespace-uri()='${element.namespaceURI}'][${nth}]`\n          );\n        }\n        break;\n      case Node.DOCUMENT_NODE:\n        return `/${segments.join(\"/\")}`;\n      case Node.TEXT_NODE:\n        for (; sibling !== null; sibling = sibling.previousSibling) {\n          if (sibling.nodeType === Node.TEXT_NODE) nth++;\n        }\n        segments.unshift(`text()[${nth}]`);\n        break;\n      case Node.PROCESSING_INSTRUCTION_NODE:\n      case Node.COMMENT_NODE:\n      case Node.DOCUMENT_TYPE_NODE:\n        throw TypeError(\n          `react-transformer: you shouldn't try to render the XPath of a comment node and/or a processing instruction.`\n        );\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        break;\n    }\n  }\n  return `/${segments.join(\"/\")}`;\n}\n","import ApplyTemplates from \"./ApplyTemplates\";\nimport CallTemplate from \"./CallTemplate\";\nimport ValueOf from \"./ValueOf\";\nimport Template from \"./Template\";\nimport Stylesheet from \"./Stylesheet\";\nimport If from \"./If\";\nimport ForEach from \"./ForEach\";\nimport { Context } from \"./Utils/Context\";\nimport \"./index.css\";\n\nexport default {\n  ApplyTemplates,\n  CallTemplate,\n  ValueOf,\n  Template,\n  Stylesheet,\n  If,\n  ForEach,\n  Context,\n};\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `ApplyTemplates`\n *\n * @interface ApplyTemplatesProps\n */\nexport interface ApplyTemplatesProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to the nodes that have to be rendered. Defaults to `node()` if not defined.\n   *\n   * @type {XPath}\n   */\n  select?: XPath;\n  /**\n   * The current rendering mode.\n   *\n   * @type {string}\n   */\n  mode?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ApplyTemplatesState {}\n\n/**\n * Applies the registered template to the selection.\n *\n * It should be called from a `Template` as `<Transformer.ApplyTemplates {...this.ctx} select={SELECT} />` (`this.ctx` is defined automatically).\n */\nexport default class ApplyTemplates extends React.Component<\n  ApplyTemplatesProps,\n  ApplyTemplatesState\n> {\n  /**\n   * Returns the current context\n   *\n   * @readonly\n   * @type {{ contextData: Context; contextNode: Node; mode?: string }}\n   */\n  get ctx(): { contextData: Context; contextNode: Node; mode?: string } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n      mode: this.props.mode,\n    };\n  }\n\n  /**\n   * Pulls the current template for the given `node` and renders it.\n   *\n   * @param {Node} node the new context node\n   * @param {number} index the react `key`\n   * @returns {React.ReactNode} the template\n   */\n  private __processTemplate(node: Node, index: number): React.ReactNode {\n    const Template = this.props.contextData.getTemplateByNode(\n      node,\n      this.props.mode\n    );\n    if (Template !== null) {\n      return <Template {...{ ...this.ctx, contextNode: node }} key={index} />;\n    } else {\n      return this.props.contextData.notFoundTemplateNode(node);\n    }\n  }\n\n  /**\n   * Renders the template on the targeted nodes.\n   *\n   * It should be called from a `Template` as `<Transformer.ApplyTemplates {...this.ctx} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.select || \"node()\",\n      this.props.contextNode,\n      XPathDataType.OrderedNodeList\n    );\n    return result.map((node, index) => {\n      return this.__processTemplate(node, index);\n    });\n  }\n}\n","import * as React from \"react\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `CallTemplate`\n *\n * @interface CallTemplatesProps\n */\nexport interface CallTemplateProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The name of the template.\n   *\n   * @type {XPath}\n   */\n  name: string;\n  /**\n   * The current rendering mode.\n   *\n   * @type {string}\n   */\n  mode?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface CallTemplateState {}\n\n/**\n * Calls the desired template.\n *\n * It should be called from a `Template` as `<Transformer.CallTemplate {...this.ctx} name={NAME} />` (`this.ctx` is defined automatically).\n *\n */\nexport default class CallTemplate extends React.Component<\n  CallTemplateProps,\n  CallTemplateState\n> {\n  /**\n   * Returns the current context\n   *\n   * @readonly\n   * @type {{ contextData: Context; contextNode: Node; mode?: string }}\n   */\n  get ctx(): {\n    contextData: Context;\n    contextNode: Node;\n    mode?: string;\n  } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n      mode: this.props.mode,\n    };\n  }\n\n  /**\n   * Renders the named template.\n   *\n   * It should be called from a `Template` as `<Transformer.CallTemplate {...this.ctx} name={NAME} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const Template = this.props.contextData.getTemplateByName(\n      this.props.name,\n      this.props.mode\n    );\n    if (Template !== null) {\n      return <Template {...this.ctx} />;\n    } else {\n      return this.props.contextData.notFoundTemplateName(this.props.name);\n    }\n  }\n}\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `ValueOf`\n *\n * @interface ValueOfProps\n */\nexport interface ValueOfProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to the nodes that have to be rendered. Defaults to `node()` if not defined.\n   *\n   * @type {XPath}\n   */\n  select?: XPath;\n  /**\n   * If more than one node is to be rendered, how they are separated. Defaults to `\"\"`.\n   *\n   * @type {string}\n   */\n  separator?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ValueOfState {}\n\n/**\n * Returns the value from the targeted nodes.\n *\n * It should be called from a `Template` as `<Transformer.ValueOf {...this.ctx} select={SELECT} />` (`this.ctx` is defined automatically).\n */\nexport default class ValueOf extends React.Component<\n  ValueOfProps,\n  ValueOfState\n> {\n  /**\n   * Renders the target nodes values.\n   *\n   * It should be called from a `Template` as `<Transformer.ValueOf {...this.ctx} test={TEST} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.select || \"node()\",\n      this.props.contextNode,\n      XPathDataType.OrderedNodeList\n    );\n    return result\n      .map((node) => {\n        return node.nodeValue;\n      })\n      .join(this.props.separator || \"\");\n  }\n}\n","import * as React from \"react\";\nimport { Context } from \"../Utils/Context\";\nimport { computeXPathFromElement } from \"../Utils/XPath\";\n\n/**\n * The properties the pass to `Template`\n *\n * @interface TemplateProps\n */\nexport interface TemplateProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n}\n\n/**\n * The inner state of the template.\n */\nexport interface TemplateState {\n  /**\n   * A XPath to the context node.\n   */\n  path: string | null;\n}\n\n/**\n * The base class of all of the templates. Every template should extend this class and the be registered using `Context.register`.\n */\nexport default abstract class Template extends React.Component<\n  TemplateProps,\n  TemplateState\n> {\n  /**\n   * An observer for the mutations on the context node.\n   */\n  private __observer: MutationObserver | null = null;\n  constructor(props: TemplateProps) {\n    super(props);\n    this.state = {\n      path: computeXPathFromElement(props.contextNode),\n    };\n    this.__onMutate = this.__onMutate.bind(this);\n    this.__setupObserver = this.__setupObserver.bind(this);\n    this.onBeforeMutate = this.onBeforeMutate.bind(this);\n    this.onAfterMutate = this.onAfterMutate.bind(this);\n  }\n\n  /**\n   * The context to pass to the children.\n   *\n   */\n  get ctx(): { contextData: Context; contextNode: Node } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n    };\n  }\n\n  /**\n   * Sets the observer for mutations on the context node.\n   */\n  private __setupObserver(): void {\n    this.__observer = new MutationObserver(this.__onMutate);\n    this.__observer.observe(this.props.contextNode, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      characterData: true,\n    });\n  }\n\n  /**\n   * The mutation handler.\n   */\n  private __onMutate(): void {\n    this.onBeforeMutate(() => {\n      this.setState(\n        {\n          path: computeXPathFromElement(this.props.contextNode),\n        },\n        () => this.forceUpdate(this.onAfterMutate)\n      );\n    });\n  }\n\n  componentDidMount(): void {\n    this.__setupObserver();\n  }\n\n  /**\n   * Event that is triggered before doing the mutation. It should call `callback` at the end.\n   */\n  onBeforeMutate: (callback: () => void) => void = (callback) => callback();\n  /**\n   * Event that is triggered at the end of the mutation.\n   */\n  onAfterMutate: () => void = () => null;\n}\n","import React from \"react\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `Stylesheet`\n *\n * @interface StylesheetProps\n */\nexport interface StylesheetProps {\n  /**\n   * The document to be rendered\n   *\n   * @type {XMLDocument}\n   */\n  contextDocument: XMLDocument;\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface StylesheetState {}\n\n/**\n * The root note, that renders the stylesheets.\n */\nexport default class Stylesheet extends React.Component<\n  StylesheetProps,\n  StylesheetState\n> {\n  /**\n   * Renders the stylesheets.\n   */\n  render(): React.ReactNode {\n    return this.props.contextData.__render(this.props.contextDocument);\n  }\n}\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `If`\n *\n * @interface IfProps\n */\nexport interface IfProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to perform. Should be a boolean.\n   *\n   * @type {XPath}\n   */\n  test: XPath;\n  /**\n   * The rendered data if the test succeeds.\n   *\n   * @type {React.ReactChildren | undefined}\n   */\n  children?: React.ReactNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IfState {}\n\n/**\n * Renders the desired content if the test succeeds, else return null.\n *\n * It should be called from a `Template` as `<Transformer.If {...this.ctx} test={TEST}>children</Transformer.If>` (`this.ctx` is defined automatically).\n *\n */\nexport default class If extends React.Component<IfProps, IfState> {\n  /**\n   * Renders the desired content if the test succeeds, else return null.\n   *\n   * It should be called from a `Template` as `<Transformer.If {...this.ctx} test={TEST} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.test,\n      this.props.contextNode,\n      XPathDataType.Boolean\n    );\n    return result !== false ? this.props.children || null : null;\n  }\n}\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `ForEach`\n *\n * @interface ForEachProps\n */\nexport interface ForEachProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to iterate from. Defaults to `node()` if not defined.\n   *\n   * @type {XPath}\n   */\n  select?: XPath;\n  /**\n   * The current rendering mode.\n   *\n   * @type {string}\n   */\n  mode?: string;\n  /**\n   * The child to be rendered.\n   *\n   */\n  do: (ctx: { contextData: Context; contextNode: Node }) => React.ReactChildren;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ForEachState {}\n\n/**\n * Renders the desired content on all of the targeted nodes.\n *\n * It should be called from a `Template` as  (`this.ctx` is defined automatically).\n *\n * ```tsx\n * <Transformer.ForEach {...this.ctx} select={SELECT} do={(ctx) =>\n *  <>\n *    ...\n *    <Transformer.ApplyTemplates {...ctx} />\n *    ...\n *  </>\n * }/>```\n *\n */\nexport default class ForEach extends React.Component<\n  ForEachProps,\n  ForEachState\n> {\n  /**\n   * Returns the current context\n   *\n   * @readonly\n   * @type {{ contextData: Context; contextNode: Node; mode?: string }}\n   */\n  get ctx(): {\n    contextData: Context;\n    contextNode: Node;\n    mode?: string;\n  } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n      mode: this.props.mode,\n    };\n  }\n  /**\n   * Renders the desired content on all of the targeted nodes.\n   *\n   * It should be called from a `Template` as  (`this.ctx` is defined automatically).\n   *\n   * ```tsx\n   * <Transformer.ForEach {...this.ctx} select={SELECT} do={(ctx) =>\n   *  <>\n   *    ...\n   *    <Transformer.ApplyTemplates {...ctx} />\n   *    ...\n   *  </>\n   * }/>```\n   *\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.select || \"node()\",\n      this.props.contextNode,\n      XPathDataType.OrderedNodeList\n    );\n    return result.map((node) =>\n      this.props.do({ ...this.ctx, contextNode: node })\n    );\n  }\n}\n","import React from \"react\";\nimport Template from \"../Template\";\nimport { XPath, XPathDataType } from \"./Types\";\n\ninterface InternalTemplate {\n  template: typeof Template;\n  path?: XPath;\n  mode?: string;\n  name?: string;\n  priority?: number;\n}\n\n/**\n * The context is shared across all templates and is used as a\n * general register and getter.\n */\nexport class Context {\n  /**\n   * A list of all registered templates.\n   *\n   * @private\n   * @type {InternalTemplate[]}\n   */\n  private __templates: InternalTemplate[] = [];\n\n  /**\n   * Guesses a namespace resolver from a given node.\n   *\n   * @param {Node} contextNode the node to guess the namespace from\n   * @returns {XPathNSResolver} a namespace resolver\n   */\n  __nsResolver(contextNode: Node): XPathNSResolver {\n    const contextDocument = (contextNode.ownerDocument ||\n      contextNode) as XMLDocument;\n    return contextDocument.createNSResolver(contextNode);\n  }\n\n  /**\n   * Sorts the templates by priority and saves it.\n   *\n   * @private\n   * @returns {InternalTemplate[]}\n   */\n  private sortedTemplate(): InternalTemplate[] {\n    this.__templates = this.__templates.sort((templateA, templateB) => {\n      if (templateA.priority !== undefined) {\n        if (templateB.priority !== undefined) {\n          return templateA.priority - templateB.priority;\n        } else {\n          return 1;\n        }\n      } else if (templateB.priority !== undefined) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n    return this.__templates;\n  }\n\n  /**\n   * A node returned when no stylesheet was found. Could be overwritten.\n   *\n   * @returns {React.ReactNode} the error node\n   */\n  notFoundStyleSheet(): React.ReactNode {\n    return (\n      <span className=\"react-transform-internal not-found\">No stylesheet</span>\n    );\n  }\n\n  /**\n   * A node returned when no template matching the name was found. Could be overwritten.\n   *\n   * @param {string} name the name of the template that was not found\n   * @returns {React.ReactNode} the error node\n   */\n  notFoundTemplateName(name: string): React.ReactNode {\n    return (\n      <span className=\"react-transform-internal not-found\">\n        Template {name} not found\n      </span>\n    );\n  }\n\n  /**\n   * A node returned when no template was found for the given node. Could be overwritten.\n   *\n   * @param {Node} node the node that did'nt have a matching template\n   * @returns {React.ReactNode} the error node\n   */\n  notFoundTemplateNode(node: Node): React.ReactNode {\n    return (\n      <span className=\"react-transform-internal not-found\">\n        No template found for {node.nodeName}\n      </span>\n    );\n  }\n\n  /**\n   * Performs a XPath query with `contextNode` as a context node, returning a type matching the `XPathDataType`.\n   *\n   * @param {XPath} query the XPath query\n   * @param {Node} contextNode the context node\n   * @param {XPathDataType} result the return type\n   * @returns {number | string | boolean | Node | Node[] | Iterable<Node> | null}\n   */\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.Any\n  ): number | string | boolean | Node | Node[] | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.Number\n  ): number | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.String\n  ): string | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.Boolean\n  ): boolean | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.UnorderedNodeIterator\n  ): Iterable<Node>;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.OrderedNodeIterator\n  ): Iterable<Node>;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.UnorderedNodeList\n  ): Node[];\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.OrderedNodeList\n  ): Node[];\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.AnyNode\n  ): Node | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.FirstNode\n  ): Node | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType\n  ): number | string | boolean | Node | Node[] | Iterable<Node> | null {\n    const doc = (contextNode.ownerDocument || contextNode) as XMLDocument;\n    if (doc === null && resultType < XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE)\n      return null;\n    else if (\n      doc === null &&\n      resultType >= XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE\n    )\n      return [];\n    const result = doc.evaluate(\n      query,\n      contextNode,\n      this.__nsResolver(doc.documentElement),\n      resultType\n    );\n    switch (resultType) {\n      case XPathDataType.Any:\n        return (\n          result.booleanValue ||\n          result.numberValue ||\n          result.singleNodeValue ||\n          result.stringValue ||\n          ([...Array(result.snapshotLength).keys()]\n            .map((_, i) => result.snapshotItem(i))\n            .filter((node) => node !== null) as Node[])\n        );\n      case XPathDataType.Number:\n        return result.numberValue;\n      case XPathDataType.String:\n        return result.stringValue;\n      case XPathDataType.Boolean:\n        return result.booleanValue;\n      case XPathDataType.AnyNode:\n        return result.singleNodeValue;\n      case XPathDataType.FirstNode:\n        return result.singleNodeValue;\n      case XPathDataType.UnorderedNodeIterator:\n      case XPathDataType.OrderedNodeIterator:\n        return (function* (): Iterable<Node> {\n          let node = null;\n          while ((node = result.iterateNext())) yield node;\n        })();\n      case XPathDataType.UnorderedNodeList:\n      case XPathDataType.OrderedNodeList:\n        return [...Array(result.snapshotLength).keys()]\n          .map((_, i) => result.snapshotItem(i))\n          .filter((node) => node !== null) as Node[];\n    }\n  }\n\n  /**\n   * Compute the correct template for the given `contextNode`\n   *\n   * @param {Node} contextNode the node to compute the template for\n   * @param {string} [mode] a rendering mode\n   * @returns {typeof Template | null} returns a renderable template if a match was found, null otherwise\n   */\n  getTemplateByNode(contextNode: Node, mode?: string): typeof Template | null {\n    const candidateTemplates = this.sortedTemplate().filter(\n      (template) => template.mode === mode && template.path !== undefined\n    );\n    for (const template of candidateTemplates) {\n      const query = `${template.path as XPath}`;\n      const allNodes = this.xpath(\n        query,\n        contextNode.parentNode || contextNode,\n        XPathDataType.UnorderedNodeList\n      );\n      const match = allNodes.find((n) => Object.is(n, contextNode));\n      if (match) {\n        return template.template;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Gives the correct template for the given name.\n   *\n   * @param {string} name the name of the template\n   * @param {string} [mode] a rendering mode\n   * @returns {typeof Template | null} returns a renderable template if a match was found, null otherwise\n   */\n  getTemplateByName(name: string, mode?: string): typeof Template | null {\n    return (\n      this.sortedTemplate().find(\n        (template) => template.name === name && template.mode === mode\n      )?.template || null\n    );\n  }\n\n  /**\n   * Registers a template by `path` or by `name`. To be able to call it from a `ApplyTemplates`, you should register by `path`, and by `name` if you want to call it from a `CallTemplate`.\n   *\n   * @param {typeof Template} template the template to register\n   * @param {({ path: XPath; mode?: string; priority?: number } | { name: string; mode?: string; priority?: number })} options see function documentation\n   */\n  register(\n    template: typeof Template,\n    options:\n      | { path: XPath; mode?: string; priority?: number }\n      | { name: string; mode?: string; priority?: number }\n  ): void {\n    this.__templates.push({\n      template,\n      path: (options as { path: XPath }).path,\n      name: (options as { name: string }).name,\n      mode: options.mode,\n      priority: options.priority,\n    });\n  }\n\n  /**\n   * Renders a document based on the registered templates, by guessing the most adequate.\n   *\n   * *Note:* you shouldn't use this function directly, but rather import `../Stylesheet` as a ReactNode.\n   *\n   * @param {XMLDocument} contextDocument the document to render\n   * @returns {React.ReactNode}\n   */\n  __render(contextDocument: XMLDocument): React.ReactNode {\n    const RootStylesheet = this.getTemplateByNode(contextDocument);\n    if (RootStylesheet === null) return this.notFoundStyleSheet();\n    return <RootStylesheet contextData={this} contextNode={contextDocument} />;\n  }\n}\n","import Transformer from \"react-transformer\";\n\nconst ctx = new Transformer.Context();\n\nexport default ctx;\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-transformer\";\n\nexport default class Root extends Transformer.Template {\n  render() {\n    return (\n      <article>\n        <Transformer.ApplyTemplates {...this.ctx} select=\"./p:root/p:title\" />\n        <Transformer.ApplyTemplates\n          {...this.ctx}\n          select=\"./p:root/*[not(self::p:title)]\"\n        />\n        <footer>\n          Here's a reference to the text of the title:{\" \"}\n          <span className=\"dont-click\" title=\"No, not me, the title!\">\n            <Transformer.ApplyTemplates\n              {...this.ctx}\n              select=\"./p:root/p:title/text()\"\n            />\n          </span>\n        </footer>\n      </article>\n    );\n  }\n}\n\nctx.register(Root, { path: \"/\" });\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-transformer\";\n\nexport default class Title extends Transformer.Template {\n  onClickHandler() {\n    const node = this.props.contextNode;\n    if ((this.props.contextNode as Element).hasAttribute(\"clicked\"))\n      node.textContent = (this.props.contextNode as Element).getAttribute(\n        \"clicked\"\n      );\n  }\n\n  render() {\n    return (\n      <h1 onClick={this.onClickHandler.bind(this)}>\n        <Transformer.ApplyTemplates {...this.ctx} />\n      </h1>\n    );\n  }\n}\n\nctx.register(Title, { path: \"p:title\" });\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-transformer\";\n\nexport default class Text extends Transformer.Template {\n  render() {\n    return (\n      <Transformer.If {...this.ctx} test=\"normalize-space()!=''\">\n        <span>\n          <Transformer.ValueOf {...this.ctx} select=\".\" />\n        </span>\n      </Transformer.If>\n    );\n  }\n}\n\nctx.register(Text, { path: \"text()\" });\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-transformer\";\n\nexport default class Para extends Transformer.Template {\n  render() {\n    return (\n      <p>\n        <Transformer.ApplyTemplates {...this.ctx} />\n      </p>\n    );\n  }\n}\n\nctx.register(Para, { path: \"p:para\" });\n","import \"./Root\";\nimport \"./Title\";\nimport \"./Text\";\nimport \"./Para\";\nimport ctx from \"./context\";\n\nexport default ctx;\n","import React from \"react\";\nimport ctx from \"./Components\";\nimport Transformer from \"react-transformer\";\n\nexport default class App extends React.Component<\n  {},\n  { document?: XMLDocument }\n> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      document: undefined,\n    };\n  }\n\n  async componentDidMount() {\n    const text = await (await fetch(\"demo.xml\")).text();\n    const xml = new DOMParser().parseFromString(text, \"text/xml\");\n    this.setState({\n      document: xml,\n    });\n  }\n\n  render() {\n    if (this.state.document !== undefined)\n      return (\n        <div className=\"App\">\n          <Transformer.Stylesheet\n            contextData={ctx}\n            contextDocument={this.state.document}\n          />\n        </div>\n      );\n    return null;\n  }\n}\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}