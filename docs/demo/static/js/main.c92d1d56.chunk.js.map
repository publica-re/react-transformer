{"version":3,"sources":["../../src/Utils/Types.ts","../../src/Utils/XPath.ts","../../src/index.tsx","../../src/ApplyTemplates/ApplyTemplates.tsx","../../src/CallTemplate/CallTemplate.tsx","../../src/ValueOf/ValueOf.tsx","../../src/Template/Template.tsx","../../src/Stylesheet/Stylesheet.tsx","../../src/If/If.tsx","../../src/ForEach/ForEach.tsx","../../src/Choose/Choose.tsx","../../src/Utils/Context.tsx","Components/context.ts","Components/Root.tsx","Components/Title.tsx","Components/Text.tsx","Components/Para.tsx","Components/Figure.tsx","Components/index.ts","App.tsx","index.tsx"],"names":["computeXPathFromElement","contextNode","segments","currentNode","element","sibling","nth","Node","document","name","localName","namespaceURI","TypeError","XPathDataType","ApplyTemplates","Template","this","props","contextData","getTemplateByNode","node","key","index","notFoundTemplateNode","xpath","select","mode","React","CallTemplate","getTemplateByName","notFoundTemplateName","ValueOf","separator","constructor","__observer","onBeforeMutate","callback","onAfterMutate","path","MutationObserver","subtree","childList","attributes","characterData","Stylesheet","__render","Component","If","result","children","ForEach","Choose","opt","Context","__templates","contextDocument","sort","templateA","templateB","className","doc","resultType","XPathResult","__nsResolver","Array","candidateTemplates","sortedTemplate","filter","template","query","allNodes","n","Object","options","priority","RootStylesheet","ctx","Transformer","Root","title","register","Title","hasAttribute","textContent","getAttribute","onClick","onClickHandler","bind","Text","test","Para","alt","cases","otherwise","src","ReactDOMServer","renderToString","App","state","undefined","fetch","text","xml","DOMParser","parseFromString","setState","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.c92d1d56.chunk.js","sourcesContent":["/**\n * A XPath query.\n */\nexport type XPath = string;\n\n/**\n * The return type of a XPath query.\n */\nexport enum XPathDataType {\n  /**\n   * Any value.\n   */\n  Any = 0,\n  /**\n   * A number.\n   */\n  Number = 1,\n  /**\n   * A string.\n   */\n  String = 2,\n  /**\n   * A boolean.\n   */\n  Boolean = 3,\n  /**\n   * An iterator on nodes, in any order.\n   */\n  UnorderedNodeIterator = 4,\n  /**\n   * An iterator on nodes, ordered from top to bottom of the XML.\n   */\n  OrderedNodeIterator = 5,\n  /**\n   * An array of nodes, in any order.\n   */\n  UnorderedNodeList = 6,\n  /**\n   * An array of nodes, ordered from top to bottom of the XML.\n   */\n  OrderedNodeList = 7,\n  /**\n   * Any node matching the query.\n   */\n  AnyNode = 8,\n  /**\n   * The first node matching the query, from top to bottom.\n   */\n  FirstNode = 9,\n}\n","import { XPath } from \"./Types\";\n\n/**\n * Computes the XPath for a given element.\n *\n * *Implementation details*:\n * - if the node or a parent has an `id` attribute, and it is the single node that has this `id`, then it will be used as the top node of the query.\n * - if the node or a parent is a processing instruction, a comment or a DTD, it will throw a `TypeError`.\n * - it will ignore document fragments.\n *\n * @param {Node} contextNode the node to compute the XPath from\n * @returns {XPath} the XPath\n */\nexport function computeXPathFromElement(contextNode: Node): XPath {\n  const segments: string[] = [];\n  let currentNode: Node | null = contextNode;\n  for (; currentNode !== null; currentNode = currentNode.parentNode) {\n    const element = currentNode as Element;\n    let sibling = contextNode.previousSibling;\n    let nth = 1;\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        if (\n          element.hasAttribute(\"id\") &&\n          document.querySelectorAll(`#${element.getAttribute(\"id\")}`).length ===\n            1\n        ) {\n          segments.unshift(`//id(\"${element.getAttribute(\"id\")}\")`);\n          return segments.join(\"/\");\n        } else {\n          const name = element.nodeName;\n          let sibling = element.previousSibling;\n          let nth = 1;\n          for (; sibling !== null; sibling = sibling.previousSibling) {\n            if (sibling.nodeName === name) nth++;\n          }\n          segments.unshift(\n            `*[local-name()='${element.localName}' and namespace-uri()='${element.namespaceURI}'][${nth}]`\n          );\n        }\n        break;\n      case Node.DOCUMENT_NODE:\n        return `/${segments.join(\"/\")}`;\n      case Node.TEXT_NODE:\n        for (; sibling !== null; sibling = sibling.previousSibling) {\n          if (sibling.nodeType === Node.TEXT_NODE) nth++;\n        }\n        segments.unshift(`text()[${nth}]`);\n        break;\n      case Node.PROCESSING_INSTRUCTION_NODE:\n      case Node.COMMENT_NODE:\n      case Node.DOCUMENT_TYPE_NODE:\n        throw TypeError(\n          `react-xml-transformer: you shouldn't try to render the XPath of a comment node and/or a processing instruction.`\n        );\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        break;\n    }\n  }\n  return `/${segments.join(\"/\")}`;\n}\n","import ApplyTemplates from \"./ApplyTemplates\";\nimport CallTemplate from \"./CallTemplate\";\nimport ValueOf from \"./ValueOf\";\nimport Template from \"./Template\";\nimport Stylesheet from \"./Stylesheet\";\nimport If from \"./If\";\nimport ForEach from \"./ForEach\";\nimport Choose from \"./Choose\";\nimport { Context } from \"./Utils/Context\";\n\nexport default {\n  ApplyTemplates,\n  CallTemplate,\n  ValueOf,\n  Template,\n  Stylesheet,\n  If,\n  ForEach,\n  Choose,\n  Context,\n};\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `ApplyTemplates`\n *\n * @interface ApplyTemplatesProps\n */\nexport interface ApplyTemplatesProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to the nodes that have to be rendered. Defaults to `node()` if not defined.\n   *\n   * @type {XPath}\n   */\n  select?: XPath;\n  /**\n   * The current rendering mode.\n   *\n   * @type {string}\n   */\n  mode?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ApplyTemplatesState {}\n\n/**\n * Applies the registered template to the selection.\n *\n * It should be called from a `Template` as `<Transformer.ApplyTemplates {...this.ctx} select={SELECT} />` (`this.ctx` is defined automatically).\n */\nexport default class ApplyTemplates extends React.Component<\n  ApplyTemplatesProps,\n  ApplyTemplatesState\n> {\n  /**\n   * Returns the current context\n   *\n   * @readonly\n   * @type {{ contextData: Context; contextNode: Node; mode?: string }}\n   */\n  get ctx(): { contextData: Context; contextNode: Node; mode?: string } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n      mode: this.props.mode,\n    };\n  }\n\n  /**\n   * Pulls the current template for the given `node` and renders it.\n   *\n   * @param {Node} node the new context node\n   * @param {number} index the react `key`\n   * @returns {React.ReactNode} the template\n   */\n  private __processTemplate(node: Node, index: number): React.ReactNode {\n    const Template = this.props.contextData.getTemplateByNode(\n      node,\n      this.props.mode\n    );\n    if (Template !== null) {\n      return <Template {...{ ...this.ctx, contextNode: node }} key={index} />;\n    } else {\n      return this.props.contextData.notFoundTemplateNode(node);\n    }\n  }\n\n  /**\n   * Renders the template on the targeted nodes.\n   *\n   * It should be called from a `Template` as `<Transformer.ApplyTemplates {...this.ctx} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.select || \"node()\",\n      this.props.contextNode,\n      XPathDataType.OrderedNodeList\n    );\n    return result.map((node, index) => {\n      return this.__processTemplate(node, index);\n    });\n  }\n}\n","import * as React from \"react\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `CallTemplate`\n *\n * @interface CallTemplatesProps\n */\nexport interface CallTemplateProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The name of the template.\n   *\n   * @type {XPath}\n   */\n  name: string;\n  /**\n   * The current rendering mode.\n   *\n   * @type {string}\n   */\n  mode?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface CallTemplateState {}\n\n/**\n * Calls the desired template.\n *\n * It should be called from a `Template` as `<Transformer.CallTemplate {...this.ctx} name={NAME} />` (`this.ctx` is defined automatically).\n *\n */\nexport default class CallTemplate extends React.Component<\n  CallTemplateProps,\n  CallTemplateState\n> {\n  /**\n   * Returns the current context\n   *\n   * @readonly\n   * @type {{ contextData: Context; contextNode: Node; mode?: string }}\n   */\n  get ctx(): {\n    contextData: Context;\n    contextNode: Node;\n    mode?: string;\n  } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n      mode: this.props.mode,\n    };\n  }\n\n  /**\n   * Renders the named template.\n   *\n   * It should be called from a `Template` as `<Transformer.CallTemplate {...this.ctx} name={NAME} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const Template = this.props.contextData.getTemplateByName(\n      this.props.name,\n      this.props.mode\n    );\n    if (Template !== null) {\n      return <Template {...this.ctx} />;\n    } else {\n      return this.props.contextData.notFoundTemplateName(this.props.name);\n    }\n  }\n}\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `ValueOf`\n *\n * @interface ValueOfProps\n */\nexport interface ValueOfProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to the nodes that have to be rendered. Defaults to `node()` if not defined.\n   *\n   * @type {XPath}\n   */\n  select?: XPath;\n  /**\n   * If more than one node is to be rendered, how they are separated. Defaults to `\"\"`.\n   *\n   * @type {string}\n   */\n  separator?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ValueOfState {}\n\n/**\n * Returns the value from the targeted nodes.\n *\n * It should be called from a `Template` as `<Transformer.ValueOf {...this.ctx} select={SELECT} />` (`this.ctx` is defined automatically).\n */\nexport default class ValueOf extends React.Component<\n  ValueOfProps,\n  ValueOfState\n> {\n  /**\n   * Renders the target nodes values.\n   *\n   * It should be called from a `Template` as `<Transformer.ValueOf {...this.ctx} test={TEST} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.select || \"node()\",\n      this.props.contextNode,\n      XPathDataType.OrderedNodeList\n    );\n    return result\n      .map((node) => {\n        return node.nodeValue;\n      })\n      .join(this.props.separator || \"\");\n  }\n}\n","import * as React from \"react\";\nimport { Context } from \"../Utils/Context\";\nimport { computeXPathFromElement } from \"../Utils/XPath\";\n\n/**\n * The properties the pass to `Template`\n *\n * @interface TemplateProps\n */\nexport interface TemplateProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n}\n\n/**\n * The inner state of the template.\n */\nexport interface TemplateState {\n  /**\n   * A XPath to the context node.\n   */\n  path: string | null;\n}\n\n/**\n * The base class of all of the templates. Every template should extend this class and the be registered using `Context.register`.\n */\nexport default abstract class Template extends React.Component<\n  TemplateProps,\n  TemplateState\n> {\n  /**\n   * An observer for the mutations on the context node.\n   */\n  private __observer: MutationObserver | null = null;\n  constructor(props: TemplateProps) {\n    super(props);\n    this.state = {\n      path: computeXPathFromElement(props.contextNode),\n    };\n    this.__onMutate = this.__onMutate.bind(this);\n    this.__setupObserver = this.__setupObserver.bind(this);\n    this.onBeforeMutate = this.onBeforeMutate.bind(this);\n    this.onAfterMutate = this.onAfterMutate.bind(this);\n  }\n\n  /**\n   * The context to pass to the children.\n   *\n   */\n  get ctx(): { contextData: Context; contextNode: Node } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n    };\n  }\n\n  /**\n   * Sets the observer for mutations on the context node.\n   */\n  private __setupObserver(): void {\n    this.__observer = new MutationObserver(this.__onMutate);\n    this.__observer.observe(this.props.contextNode, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      characterData: true,\n    });\n  }\n\n  /**\n   * The mutation handler.\n   */\n  private __onMutate(): void {\n    this.onBeforeMutate(() => {\n      this.setState(\n        {\n          path: computeXPathFromElement(this.props.contextNode),\n        },\n        () => this.forceUpdate(this.onAfterMutate)\n      );\n    });\n  }\n\n  componentDidMount(): void {\n    this.__setupObserver();\n  }\n\n  /**\n   * Event that is triggered before doing the mutation. It should call `callback` at the end.\n   */\n  onBeforeMutate: (callback: () => void) => void = (callback) => callback();\n  /**\n   * Event that is triggered at the end of the mutation.\n   */\n  onAfterMutate: () => void = () => null;\n}\n","import React from \"react\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `Stylesheet`\n *\n * @interface StylesheetProps\n */\nexport interface StylesheetProps {\n  /**\n   * The document to be rendered\n   *\n   * @type {XMLDocument}\n   */\n  contextDocument: XMLDocument;\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface StylesheetState {}\n\n/**\n * The root note, that renders the stylesheets.\n */\nexport default class Stylesheet extends React.Component<\n  StylesheetProps,\n  StylesheetState\n> {\n  /**\n   * Renders the stylesheets.\n   */\n  render(): React.ReactNode {\n    return this.props.contextData.__render(this.props.contextDocument);\n  }\n}\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `If`\n *\n * @interface IfProps\n */\nexport interface IfProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to perform. Should be a boolean.\n   *\n   * @type {XPath}\n   */\n  test: XPath;\n  /**\n   * The rendered data if the test succeeds.\n   *\n   * @type {React.ReactChildren | undefined}\n   */\n  children?: React.ReactNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IfState {}\n\n/**\n * Renders the desired content if the test succeeds, else return null.\n *\n * It should be called from a `Template` as `<Transformer.If {...this.ctx} test={TEST}>children</Transformer.If>` (`this.ctx` is defined automatically).\n *\n */\nexport default class If extends React.Component<IfProps, IfState> {\n  /**\n   * Renders the desired content if the test succeeds, else return null.\n   *\n   * It should be called from a `Template` as `<Transformer.If {...this.ctx} test={TEST} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.test,\n      this.props.contextNode,\n      XPathDataType.Boolean\n    );\n    return result !== false ? this.props.children || null : null;\n  }\n}\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * The properties the pass to `ForEach`\n *\n * @interface ForEachProps\n */\nexport interface ForEachProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The XPath to iterate from. Defaults to `node()` if not defined.\n   *\n   * @type {XPath}\n   */\n  select?: XPath;\n  /**\n   * The current rendering mode.\n   *\n   * @type {string}\n   */\n  mode?: string;\n  /**\n   * The child to be rendered.\n   *\n   */\n  do: (ctx: { contextData: Context; contextNode: Node }) => React.ReactChildren;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ForEachState {}\n\n/**\n * Renders the desired content on all of the targeted nodes.\n *\n * It should be called from a `Template` as  (`this.ctx` is defined automatically).\n *\n * ```tsx\n * <Transformer.ForEach {...this.ctx} select={SELECT} do={(ctx) =>\n *  <>\n *    ...\n *    <Transformer.ApplyTemplates {...ctx} />\n *    ...\n *  </>\n * }/>```\n *\n */\nexport default class ForEach extends React.Component<\n  ForEachProps,\n  ForEachState\n> {\n  /**\n   * Returns the current context\n   *\n   * @readonly\n   * @type {{ contextData: Context; contextNode: Node; mode?: string }}\n   */\n  get ctx(): {\n    contextData: Context;\n    contextNode: Node;\n    mode?: string;\n  } {\n    return {\n      contextData: this.props.contextData,\n      contextNode: this.props.contextNode,\n      mode: this.props.mode,\n    };\n  }\n  /**\n   * Renders the desired content on all of the targeted nodes.\n   *\n   * It should be called from a `Template` as  (`this.ctx` is defined automatically).\n   *\n   * ```tsx\n   * <Transformer.ForEach {...this.ctx} select={SELECT} do={(ctx) =>\n   *  <>\n   *    ...\n   *    <Transformer.ApplyTemplates {...ctx} />\n   *    ...\n   *  </>\n   * }/>```\n   *\n   */\n  render(): React.ReactNode {\n    const result = this.props.contextData.xpath(\n      this.props.select || \"node()\",\n      this.props.contextNode,\n      XPathDataType.OrderedNodeList\n    );\n    return result.map((node) =>\n      this.props.do({ ...this.ctx, contextNode: node })\n    );\n  }\n}\n","import * as React from \"react\";\nimport { XPath, XPathDataType } from \"../Utils/Types\";\nimport { Context } from \"../Utils/Context\";\n\n/**\n * A test case\n */\nexport interface ChooseCase {\n  /**\n   *  The XPath for the test (should be a boolean)\n   *\n   * @type {XPath}\n   */\n  test: XPath;\n  /**\n   * The rendered node if the test succeeds\n   *\n   * @type {React.ReactNode}\n   */\n  node: React.ReactNode;\n}\n\n/**\n * The properties the pass to `Chosse`\n *\n * @interface ChooseProps\n */\nexport interface ChooseProps {\n  /**\n   * The Context from which the templates are pulled.\n   *\n   * @type {Context}\n   */\n  contextData: Context;\n  /**\n   * The node that is currently being rendered.\n   *\n   * @type {Node}\n   */\n  contextNode: Node;\n  /**\n   * The various match cases\n   *\n   * @type {ChooseCase[]}\n   */\n  cases: ChooseCase[];\n  /**\n   * The child to be rendered if no test succeeds\n   *\n   * @type {React.ReactNode}\n   */\n  otherwise: React.ReactNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ChooseState {}\n\n/**\n * Chooses the first node whoose test succeeds.\n *\n * It should be called from a `Template` as `<Transformer.Choose {...this.ctx} cases={...} otherwise={...} />` (`this.ctx` is defined automatically).\n *\n */\nexport default class Choose extends React.Component<ChooseProps, ChooseState> {\n  /**\n   * Chooses the first node whoose test succeeds.\n   *\n   * It should be called from a `Template` as `<Transformer.Choose {...this.ctx} cases={...} otherwise={...} />` (`this.ctx` is defined automatically).\n   *\n   * @returns {React.ReactNode}\n   */\n  render(): React.ReactNode {\n    for (let opt of this.props.cases) {\n      const result = this.props.contextData.xpath(\n        opt.test,\n        this.props.contextNode,\n        XPathDataType.Boolean\n      );\n      if (result !== false) {\n        return opt.node;\n      }\n    }\n    return this.props.otherwise;\n  }\n}\n","import React from \"react\";\nimport Template from \"../Template\";\nimport { XPath, XPathDataType } from \"./Types\";\n\ninterface InternalTemplate {\n  template: typeof Template;\n  path?: XPath;\n  mode?: string;\n  name?: string;\n  priority?: number;\n}\n\n/**\n * The context is shared across all templates and is used as a\n * general register and getter.\n */\nexport class Context {\n  /**\n   * A list of all registered templates.\n   *\n   * @private\n   * @type {InternalTemplate[]}\n   */\n  private __templates: InternalTemplate[] = [];\n\n  /**\n   * Guesses a namespace resolver from a given node.\n   *\n   * @param {Node} contextNode the node to guess the namespace from\n   * @returns {XPathNSResolver} a namespace resolver\n   */\n  __nsResolver(contextNode: Node): XPathNSResolver {\n    const contextDocument = (contextNode.ownerDocument ||\n      contextNode) as XMLDocument;\n    return contextDocument.createNSResolver(contextNode);\n  }\n\n  /**\n   * Sorts the templates by priority and saves it.\n   *\n   * @private\n   * @returns {InternalTemplate[]}\n   */\n  private sortedTemplate(): InternalTemplate[] {\n    this.__templates = this.__templates.sort((templateA, templateB) => {\n      if (templateA.priority !== undefined) {\n        if (templateB.priority !== undefined) {\n          return templateA.priority - templateB.priority;\n        } else {\n          return 1;\n        }\n      } else if (templateB.priority !== undefined) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n    return this.__templates;\n  }\n\n  /**\n   * A node returned when no stylesheet was found. Could be overwritten.\n   *\n   * @returns {React.ReactNode} the error node\n   */\n  notFoundStyleSheet(): React.ReactNode {\n    return (\n      <span className=\"react-transform-internal not-found\">No stylesheet</span>\n    );\n  }\n\n  /**\n   * A node returned when no template matching the name was found. Could be overwritten.\n   *\n   * @param {string} name the name of the template that was not found\n   * @returns {React.ReactNode} the error node\n   */\n  notFoundTemplateName(name: string): React.ReactNode {\n    return (\n      <span className=\"react-transform-internal not-found\">\n        Template {name} not found\n      </span>\n    );\n  }\n\n  /**\n   * A node returned when no template was found for the given node. Could be overwritten.\n   *\n   * @param {Node} node the node that did'nt have a matching template\n   * @returns {React.ReactNode} the error node\n   */\n  notFoundTemplateNode(node: Node): React.ReactNode {\n    return (\n      <span className=\"react-transform-internal not-found\">\n        No template found for {node.nodeName}\n      </span>\n    );\n  }\n\n  /**\n   * Performs a XPath query with `contextNode` as a context node, returning a type matching the `XPathDataType`.\n   *\n   * @param {XPath} query the XPath query\n   * @param {Node} contextNode the context node\n   * @param {XPathDataType} result the return type\n   * @returns {number | string | boolean | Node | Node[] | Iterable<Node> | null}\n   */\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.Any\n  ): number | string | boolean | Node | Node[] | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.Number\n  ): number | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.String\n  ): string | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.Boolean\n  ): boolean | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.UnorderedNodeIterator\n  ): Iterable<Node>;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.OrderedNodeIterator\n  ): Iterable<Node>;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.UnorderedNodeList\n  ): Node[];\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.OrderedNodeList\n  ): Node[];\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.AnyNode\n  ): Node | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType.FirstNode\n  ): Node | null;\n\n  xpath(\n    query: XPath,\n    contextNode: Node,\n    resultType: XPathDataType\n  ): number | string | boolean | Node | Node[] | Iterable<Node> | null {\n    const doc = (contextNode.ownerDocument || contextNode) as XMLDocument;\n    if (doc === null && resultType < XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE)\n      return null;\n    else if (\n      doc === null &&\n      resultType >= XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE\n    )\n      return [];\n    const result = doc.evaluate(\n      query,\n      contextNode,\n      this.__nsResolver(doc.documentElement),\n      resultType\n    );\n    switch (resultType) {\n      case XPathDataType.Any:\n        return (\n          result.booleanValue ||\n          result.numberValue ||\n          result.singleNodeValue ||\n          result.stringValue ||\n          ([...Array(result.snapshotLength).keys()]\n            .map((_, i) => result.snapshotItem(i))\n            .filter((node) => node !== null) as Node[])\n        );\n      case XPathDataType.Number:\n        return result.numberValue;\n      case XPathDataType.String:\n        return result.stringValue;\n      case XPathDataType.Boolean:\n        return result.booleanValue;\n      case XPathDataType.AnyNode:\n        return result.singleNodeValue;\n      case XPathDataType.FirstNode:\n        return result.singleNodeValue;\n      case XPathDataType.UnorderedNodeIterator:\n      case XPathDataType.OrderedNodeIterator:\n        return (function* (): Iterable<Node> {\n          let node = null;\n          while ((node = result.iterateNext())) yield node;\n        })();\n      case XPathDataType.UnorderedNodeList:\n      case XPathDataType.OrderedNodeList:\n        return [...Array(result.snapshotLength).keys()]\n          .map((_, i) => result.snapshotItem(i))\n          .filter((node) => node !== null) as Node[];\n    }\n  }\n\n  /**\n   * Compute the correct template for the given `contextNode`\n   *\n   * @param {Node} contextNode the node to compute the template for\n   * @param {string} [mode] a rendering mode\n   * @returns {typeof Template | null} returns a renderable template if a match was found, null otherwise\n   */\n  getTemplateByNode(contextNode: Node, mode?: string): typeof Template | null {\n    const candidateTemplates = this.sortedTemplate().filter(\n      (template) => template.mode === mode && template.path !== undefined\n    );\n    for (const template of candidateTemplates) {\n      const query = `${template.path as XPath}`;\n      const allNodes = this.xpath(\n        query,\n        contextNode.parentNode || contextNode,\n        XPathDataType.UnorderedNodeList\n      );\n      const match = allNodes.find((n) => Object.is(n, contextNode));\n      if (match) {\n        return template.template;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Gives the correct template for the given name.\n   *\n   * @param {string} name the name of the template\n   * @param {string} [mode] a rendering mode\n   * @returns {typeof Template | null} returns a renderable template if a match was found, null otherwise\n   */\n  getTemplateByName(name: string, mode?: string): typeof Template | null {\n    return (\n      this.sortedTemplate().find(\n        (template) => template.name === name && template.mode === mode\n      )?.template || null\n    );\n  }\n\n  /**\n   * Registers a template by `path` or by `name`. To be able to call it from a `ApplyTemplates`, you should register by `path`, and by `name` if you want to call it from a `CallTemplate`.\n   *\n   * @param {typeof Template} template the template to register\n   * @param {({ path: XPath; mode?: string; priority?: number } | { name: string; mode?: string; priority?: number })} options see function documentation\n   */\n  register(\n    template: typeof Template,\n    options:\n      | { path: XPath; mode?: string; priority?: number }\n      | { name: string; mode?: string; priority?: number }\n  ): void {\n    this.__templates.push({\n      template,\n      path: (options as { path: XPath }).path,\n      name: (options as { name: string }).name,\n      mode: options.mode,\n      priority: options.priority,\n    });\n  }\n\n  /**\n   * Renders a document based on the registered templates, by guessing the most adequate.\n   *\n   * *Note:* you shouldn't use this function directly, but rather import `../Stylesheet` as a ReactNode.\n   *\n   * @param {XMLDocument} contextDocument the document to render\n   * @returns {React.ReactNode}\n   */\n  __render(contextDocument: XMLDocument): React.ReactNode {\n    const RootStylesheet = this.getTemplateByNode(contextDocument);\n    if (RootStylesheet === null) return this.notFoundStyleSheet();\n    return <RootStylesheet contextData={this} contextNode={contextDocument} />;\n  }\n}\n","import Transformer from \"react-xml-transformer\";\n\nconst ctx = new Transformer.Context();\n\nexport default ctx;\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-xml-transformer\";\n\nexport default class Root extends Transformer.Template {\n  render() {\n    return (\n      <article>\n        <Transformer.ApplyTemplates {...this.ctx} select=\"./p:root/p:title\" />\n        <Transformer.ApplyTemplates\n          {...this.ctx}\n          select=\"./p:root/*[not(self::p:title)]\"\n        />\n        <footer>\n          Here's a reference to the text of the title:{\" \"}\n          <span className=\"dont-click\" title=\"No, not me, the title!\">\n            <Transformer.ApplyTemplates\n              {...this.ctx}\n              select=\"./p:root/p:title/text()\"\n            />\n          </span>\n        </footer>\n      </article>\n    );\n  }\n}\n\nctx.register(Root, { path: \"/\" });\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-xml-transformer\";\n\nexport default class Title extends Transformer.Template {\n  onClickHandler() {\n    const node = this.props.contextNode;\n    if ((this.props.contextNode as Element).hasAttribute(\"clicked\"))\n      node.textContent = (this.props.contextNode as Element).getAttribute(\n        \"clicked\"\n      );\n  }\n\n  render() {\n    return (\n      <h1 onClick={this.onClickHandler.bind(this)}>\n        <Transformer.ApplyTemplates {...this.ctx} />\n      </h1>\n    );\n  }\n}\n\nctx.register(Title, { path: \"p:title\" });\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-xml-transformer\";\n\nexport default class Text extends Transformer.Template {\n  render() {\n    return (\n      <Transformer.If {...this.ctx} test=\"normalize-space()!=''\">\n        <span>\n          <Transformer.ValueOf {...this.ctx} select=\".\" />\n        </span>\n      </Transformer.If>\n    );\n  }\n}\n\nctx.register(Text, { path: \"text()\" });\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-xml-transformer\";\n\nexport default class Para extends Transformer.Template {\n  render() {\n    return (\n      <p>\n        <Transformer.ApplyTemplates {...this.ctx} />\n      </p>\n    );\n  }\n}\n\nctx.register(Para, { path: \"p:para\" });\n","import * as React from \"react\";\nimport ctx from \"./context\";\nimport Transformer from \"react-xml-transformer\";\nimport ReactDOMServer from \"react-dom/server\";\n\nexport default class Para extends Transformer.Template {\n  render() {\n    const alt = (\n      <Transformer.Choose\n        {...this.ctx}\n        cases={[\n          {\n            test: \"./p:img/@alt\",\n            node: <Transformer.ValueOf {...this.ctx} select=\"./p:img/@alt\" />,\n          },\n          {\n            test: \"./p:title\",\n            node: (\n              <Transformer.ValueOf {...this.ctx} select=\"./p:title/text()\" />\n            ),\n          },\n        ]}\n        otherwise={\"no alternating text\"}\n      />\n    );\n    return (\n      <figure>\n        <img\n          src={ReactDOMServer.renderToString(\n            <Transformer.ValueOf {...this.ctx} select=\"./p:img/@src\" />\n          )}\n          alt={ReactDOMServer.renderToString(alt)}\n        />\n        <h2>\n          <Transformer.ApplyTemplates {...this.ctx} select=\"./p:title/text()\" />\n        </h2>\n      </figure>\n    );\n  }\n}\n\nctx.register(Para, { path: \"p:figure\" });\n","import \"./Root\";\nimport \"./Title\";\nimport \"./Text\";\nimport \"./Para\";\nimport \"./Figure\";\nimport ctx from \"./context\";\n\nexport default ctx;\n","import React from \"react\";\nimport ctx from \"./Components\";\nimport Transformer from \"react-xml-transformer\";\n\nexport default class App extends React.Component<\n  {},\n  { document?: XMLDocument }\n> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      document: undefined,\n    };\n  }\n\n  async componentDidMount() {\n    const text = await (await fetch(\"demo.xml\")).text();\n    const xml = new DOMParser().parseFromString(text, \"text/xml\");\n    this.setState({\n      document: xml,\n    });\n  }\n\n  render() {\n    if (this.state.document !== undefined)\n      return (\n        <div className=\"App\">\n          <Transformer.Stylesheet\n            contextData={ctx}\n            contextDocument={this.state.document}\n          />\n        </div>\n      );\n    return null;\n  }\n}\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}